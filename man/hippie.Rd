% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hippie.R
\name{hippie}
\alias{hippie}
\title{High-dimensional Iterated Perturbed Parameter Inference Engine (HIPPIE)}
\arguments{
\item{Nhippie}{The number of iterations to perform.}

\item{islands}{The number of islands for the adapted simulations.}

\item{Np}{the number of particles inside each island.}

\item{rw.sd}{specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the \code{\link{rw.sd}} function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as \code{time}).
If \code{transform = TRUE}, then they are applied on the estimation scale.}

\item{cooling.type, cooling.fraction.50}{specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
\code{cooling.type} specifies the nature of the cooling schedule.
See below (under \dQuote{Specifying the perturbations}) for more detail.}
}
\value{
Upon successful completion, \code{hippie} returns an object of class
\sQuote{hippied.spatPomp}.
}
\description{
An algorithm for estimating the parameters of a spatiotemporal partially-observed Markov process.
Running \code{hippie} causes the algorithm to perform a specified number of iterations of adapted simulations with parameter perturbation and parameter resamplings.
At each iteration, adapted simulations are performed on a perturbed version of the model, in which the parameters to be estimated are subjected to random perturbations at each observation.
After cycling through the data, each island's weight is calculated and is used to rank the islands. The highest ranking islands are recycled into the next iteration.
This extra variability introduced through parameter perturbation effectively smooths the likelihood surface and combats particle depletion by introducing diversity into particle population.
As the iterations progress, the magnitude of the perturbations is diminished according to a user-specified cooling schedule.
}
\section{Methods}{

The following methods are available for such an object:
\describe{
\item{\code{\link{coef}}}{ extracts the point estimate }
}
}

\section{Specifying the perturbations}{

The \code{rw.sd} function simply returns a list containing its arguments as unevaluated expressions.
These are then evaluated in a context containing the model \code{time} variable.  This allows for easy specification of the structure of the perturbations that are to be applied.
For example,
\preformatted{
    rw.sd(a=0.05, b=ifelse(0.2,time==time[1],0),
          c=ivp(0.2), d=ifelse(time==time[13],0.2,0),
          e=ivp(0.2,lag=13), f=ifelse(time<23,0.02,0))
}
results in perturbations of parameter \code{a} with s.d. 0.05 at every time step, while parameters \code{b} and \code{c} both get perturbations of s.d. 0.2 only before the first observation.
Parameters \code{d} and \code{e}, by contrast, get perturbations of s.d.  0.2 only before the thirteenth observation.
Finally, parameter \code{f} gets a random perturbation of size 0.02 before every observation falling before \eqn{t=23}.

On the \eqn{m}-th HIPPIE iteration, prior to time-point \eqn{n}, the \eqn{d}-th parameter is given a random increment normally distributed with mean \eqn{0} and standard deviation \eqn{c_{m,n} \sigma_{d,n}}{c[m,n] sigma[d,n]}, where \eqn{c} is the cooling schedule and \eqn{\sigma}{sigma} is specified using \code{rw.sd}, as described above.
Let \eqn{N} be the length of the time series and \eqn{\alpha=}{alpha=}\code{cooling.fraction.50}.
Then, when \code{cooling.type="geometric"}, we have \deqn{c_{m,n}=\alpha^{\frac{n-1+(m-1)N}{50N}}.}{c[m,n]=alpha^((n-1+(m-1)N)/(50N)).}
When \code{cooling.type="hyperbolic"}, we have \deqn{c_{m,n}=\frac{s+1}{s+n+(m-1)N},}{c[m,n]=(s+1)/(s+n+(m-1)N),} where \eqn{s} satisfies \deqn{\frac{s+1}{s+50N}=\alpha.}{(s+1)/(s+50N)=alpha.}
Thus, in either case, the perturbations at the end of 50 HIPPIE iterations are a fraction \eqn{\alpha}{alpha} smaller than they are at first.
}

\seealso{
Other particle filter methods: 
\code{\link{abfir}()},
\code{\link{abf}()},
\code{\link{bootgirf}()},
\code{\link{bpfilter-spatPomp}},
\code{\link{girf}()},
\code{\link{ienkf-spatPomp}},
\code{\link{igirf}()}

Other \pkg{spatPomp} parameter estimation methods: 
\code{\link{enkf}()},
\code{\link{ienkf-spatPomp}}
}
\concept{\pkg{spatPomp} parameter estimation methods}
\concept{particle filter methods}
